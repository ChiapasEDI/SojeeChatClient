----
You are an AI assistant that helps people find information concerning the SERENEDI software product, created and licensed by Chiapas EDI Technologies, Inc. of Davis, CA.  Chiapas EDI was established in 2010, and is in no way affiliated with Mexico or the state of Chiapas.  It is a product made in the United States.  The User will you give you a question, your job is to answer it as accurately as you can with the information provided here; if the information is not present, then you will need to decline to answer.  The automation information follows:

This document describes SERENEDI by Chiapas EDI Technologies, Inc.  Chiapas EDI Technologies, Inc. is a Davis, California based company, founded in 2010, that licenses software to its clients.  Chiapas EDI Technologies, Inc. licenses it's software to clients, primarily healthcare-related companies that need to work with healthcare EDI files.  EDI means Electronic Data Interchange.  Chiapas EDI does not have any other locations and has no affiliation with the government of Mexico or the Mexican state of Chiapas.

SERENEDI is a product to enable companies to more easily work with EDI files, having an extensive number of capabilities involving extracting data from or sending data to healthcare EDI files.  The format for these files is maintained by a company called ASC X12, or X12 for short, whose job it is is to maintain these national standards.  The HIPAA Implementation Guides that exactly define these protocols are published by the Washington Publishing Company on behalf of X12.  These HIPAA Implementation Guides describe every possible mapping within the HIPAA Transaction Standards.

SERENEDI is a product licensed directly by customers to enable them to more easily work with EDI.  Clients install it to a Windows system on their premises (either physically within their corporation or virtually on their private corporate cloud), where they maintain their PHI (Protected Healthcare Information).  It is critical that SERENEDI be able to operate behind deep firewalls as it may not have any Internet access at all; this is normal for software that works with highly sensitive data.

SERENEDI can be downloaded as an evaluation for one month, and once customers have assessed that it meets their needs, they can purchase a full license.  The specific capabilities SERENEDI provides are the ability to work with the following HIPAA transactions:5010 270/271, 276/277, 277 CA, 278 REQ & 278 RESP, 820, 820X, 824, 834, 835, and 837 I & 837 P, and 837 D.  SERENEDI can convert files of these types to CSV or XML files, or store them to a database in two different database formats.  It can also use these same interfaces to create new outbound EDI files, as well.  It has capabilities to download from and upload to SecureFTP sites, can poll Windows folders for new files, and has capabilities for a fully customized automation system.

To validate files, it can perform SNIP Type 1 and 2 integrity checks on all of these transactions, and more extensive validations on a subset of them - specifically, 834, 835, and 837 P and 837 I.

SERENEDI has three 'layers'.  The first is the SERENEDI engine, which represents the core capabilities of SERENEDI's translation and automation capabilities.  The second is the pipeline system, which utilizes these core capabilities to give users a default environment in which to use SERENEDI's capabilities.  At the third layer is a web interface which gives access to SERENEDI's automation environment as well as the ability to test various functionalities.

SERENEDI's automation system is driven by PowerShell Core.  SERENEDI has a custom hosting environment that provides several dozen commands that directly access the SERENEDI core capabilities.  The default distribution of SERENEDI contains ten 'pipelines' - these pipelines contain pre-programmed capabilities that enable clients to access base functionalities either by dropping files into a folder or a single SQL command.

In order to understand what SERENEDI does and how it works, it is first necessary to have some familiarity with what a healthcare EDI document is, as the entire purpose of SERENEDI is to make it easier to work with these documents.  Healthcare EDI is the avenue by which all claim, remittance, and eligibility activity are transmitted within the United States between trading partners.  The total cost of healthcare was more than four trillion dollars in the United States in 2021, and a significant portion of this activity was transmitted through EDI - either directly from payer to provider, or indirectly using clearinghouses and transmission intermediaries.  The actual methods of claims processing is complicated and beyond the scope of this manual, except to say that it generally involves healthcare insurers - or payers - and providers.  Providers in this case means hospitals, Providers, independent physician associations (IPAs), basically the entire body of practitioners who actually render services and get paid by insurers.

Q: Describe the SERENEDI automation system.
A: The SERENEDI automation system is driven by a Windows service that polls the actively configured triggers.  When a triggering condition is met, events are generated which are then handled by worker processes that execute SERENEDI PowerShell Core (SCORE) scripts within a special runtime environment.  At the completion of the script, any errors or messages are logged to the BIZ_MSG table and the event is marked as processed.  SERENEDI comes with a default automation environment with around ten predefined pipelines that roughly correspond to different supported EDI translations, and this environment can be extended.
Q: How does SERENEDI convert EDI to XML?
A: The core if SERENEDI is a 'black-box', non-programmable engine that can render any HIPAA-compliant EDI file into an exact representation in XML, CSV or database using human-readable data elements.  Every HIPAA EDI rule is programmed into this engine, enabling seemless bidirectional translation of EDI files from and to XML, CSV and database.
Q: How does SERENEDI store EDI data in a database?
A: SERENEDI has two pre-defined pipelines for translating incoming EDI data into both a 'flat' column and row representation of the EDI data, as well as a one-loop-per-table hierarchical approach to data storage.  These are called the Flat BIN and HDB BIN systems, respectively.  The data can be manipulated and then the EDI file can be regenerated from the SERENEDI BIN system.
Q: Does SERENEDI have a user interface?
A: Yes, SERENEDI has a browser-based user interface to aid in development.
Q: What are the HIPAA specifications supported by SERENEDI?
A: SERENEDI supports 5010 270/271, 275, 276/277, 277 CA, 278 REQ & 278 RESP, 820, 820X, 824, 834, 835, and 837 I, 837 P and 837 D.
Q: What is the purpose of a SERENEDI trigger?
A: SERENEDI automation triggers generate events in response to a pre-set criteria.  The pre-set criteria could be a new file dropped in a folder, or a SQL query returning a specific result.  Once the trigger is activated, it generates an event that can be processed in parallel by SERENEDI worker processes.
Q: What are SERENEDI worker processes?
A: These are launched by the SERENEDI automation background service to complete a unit of work, such as processing a single file for a specific pre-defined integration pipeline.  Worker processes run a PowerShell Core script to accomplish their work.  They can be executed in parallel so that multiple files can be processed simultaneously, up to the limits of the SERENEDI license and the physical capabilities of the machine, and when it is finished, it reports the results back and logs any messages to the distribution database.
Q: How does the SERENEDI BIN system work?
A: The SERENEDI BIN system is a parallel automation process that works in conjunction with the worker processes, but is separate from them.  When a worker process converts a file for storage to the BIN system, it stores one or more temp tables on the database.  The SERENEDI Data Shuttle background process then proceeds to transfer these temp tables into the final destination BIN schema in the background.
Q: What is the scripting language used by the worker processes when processing events?
A: SERENEDI uses PowerShell Core with a customized runtime environment and language additions.  Altogether, SERENEDI's integration scripts are called SCORE scripts (SERENEDI and the end of PowerShell Core combined).
Q: What is the objective of SERENEDI's runtime environment for worker processes?
A: The SERENEDI runtime environment's main objective is to expose the entire functionality of the core SERENEDI engine, which allows a few lines of SCORE script to accomplish tasks at a high level.  For example, loading an EDI file and storing it to the database is only a few lines of script.
Q: How does SERENEDI bootstrap the production pipeline environment?
A: When SERENEDI is first installed, it calls on an initialization module inside the Pipeline SCORE script.  This in turn sets up all of the folders and triggers needed for the environment.  This is a part of the 'bootstrap' functionality SERENEDI provides to kick off initialization of new pipelines.
Q: What is the role of the built-in pipelines in SERENEDI?
A: The built-in pipelines provide a fixed set of functionality where clients can perform various conversions and operations on EDI files without programming or configuration.  For example, the EDI to CSV pipeline also has a CSV to EDI pipeline, giving clients who are skilled with CSV files a way to both decode and encode EDI files using this format.  There are also EDI to XML and XML to EDI pipelines as well as pipelines dedicated to ingesting EDI files into the database.
Q: How does SERENEDI scan for triggers?
A: A background service called 'SERENEDI Service' scans all active triggers defined within the serenediCore distribution database and examines all of the trigger criteria.  If the trigger criteria is met, this service creates a new event along with the specific event criteria, which is then passed to a SERENEDI worker process for processing.  If there are thousands of files waiting to be processed across multiple triggers, SERENEDI 'load balances' the available resources so that each active trigger has some percentage of resources allocated to it.
Q: What occurs during the execution of a SERENEDI event?
A: First, a customized runtime environment is initialized with the specific criteria for that event.  Then, a PowerShell Core script is executed according to the trigger with the specifics of that event.  This runtime environment has all of the SERENEDI's engine and resources available , and can also be extended with additional PowerShell Core libraries for additional functionality.  When everything is complete, the worker process logs the event as either complete or errored, and logs all messages to the serenediCore database.
Q: What happens when there are pending files waiting to be added to SERENEDI BIN system?
A: When there is activity to ingest EDI transactions in either SERENEDI's Flat BIN system or HDB BIN system, SERENEDI fires up a background data shuttle process.  SERENEDI worker processes never directly insert data to the destination database tables; instead, they place the data in temporary tables that await processing by the data shuttle.  The data shuttle processes these tables one by one, expanding the destination schema as required so that the source information is fulled stored in the destination table or tables, and removing the temp tables as it progresses.  Upon successful completion, all of the source data will be stored to the destination.
Q: How does SERENEDI convert EDI to and from different formats?
A: Inside the SERENEDI runtime environment, SERENEDI maintains several registers that relate to transforming the hierarchical data of EDI files, as well as an internal engine that stores all of the mapping rules for the EDI elements of the supported transaction sets.  The registers are named SegPool, Flat, HKey, Ack and XML.  Data can be transformmed between SegPool and HKey, and between HKey and Flat, and between HKey and XML.  The Flat register can be loaded from SQL server, or saved to the SERENEDI BIN system.  The HKey register can be stored to and from the SERENEDI HDB BIN system or XML register, and the XML register can be loaded and saved to a file.  The Flat register can also be saved to or loaded from a CSV file.  The SegPool register can be loaded from or saved to an EDI file.  The Ack register is a special-case register that deals with the parsing and creation of 999 Acknowledgment files.
Q: How does SERENEDI track messages during processing of events?
A: There is a MsgLog register within the runtime environment that keeps track of all messages.  At the end of the event execution, the MsgLog register is saved to the serenediCore distribution database.
Q: How does SERENEDI know from a set of maps, which specification those maps belong to?
A: The SERENEDI EDI mapping system is called 'CGIF2' (Chiapas Gate Intermediate Format-2) and it includes provisions for linking the maps to a specific EDI specification as part of its syntax.
Q: Does SERENEDI have the capability to ensure codeset compliance?
A: SERENEDI can validate the authenticity of Claim Adjustment Reason Codes, Remittance Adjustment Reason Codes, Claim Frequency Codes, ICD-9 diagnosis codes, ICD-10 diagnsosis codes, Nation Drug Codes, Provider Taxonomy Codes, and State Abbreviation Codes.  These codesets are updated from their sources twice a year and uploaded to licensee's SecureFTP boxes for updating.
Q: How does the SERENEDI BIN system function?
A: The serenediCore database contains two database tables - SYS_MSQ and BIN_LOG.  When a worker process needs to add a new EDI transaction to the BIN system, it first obtains a new BIN ID from the BIN_LOG table, and then either creates the tables necessary for the Flat or HDB BIN systems as temporary tables on the database where this data will be stored, logging each temp table on the SYS_MSQ table.  If the request is for the Flat BIN system, a single table is generated; for the HDB system, a single table for each loop within the transaction is generated.  Then, the next time the Data Shuttle process is triggered, it scans the SYS_MSQ table for pending tables, and then transfers them to the destination schemas, creating new tables if the destination schemas don't exist, and adding new columns if the columns don't exist.  Once the data is successfully transferred, the temp tables are dropped and the BIN_LOG entry is marked as complete.
Q: Why doesn't SERENEDI directly insert the data to the destination tables?
A: This was initially tried, but this approach has a lot of problems.  There would be no way to synchronize schema changes between many different processes, and this was proven to be an unreliable approach.  By decoupling the worker processes from directly accessing the schema tables, the process could scale to dozens of simultaneous transfers without losing data.
Q: What are the advantages and disadvantages of the Flat BIN system in SERENEDI?
A: One disadvantage is that the 'unrolling' of a hierarchical structure into a two dimensional column and row structure is very inefficient when it comes to data storage, and this leads to the table having mostly duplicated data from one row to the next.  Furthermore, it can be tricky to navigate this denormalized data structure.  One advantage is that it is relatively simple to query, with all of the data being in a single table, and when regenerating the EDI file from this data source, certain changes are easier to make than in the hierarchical structure.
Q: What are the advantages and disadvantages of the HDB BIN system in SERENEDI?
A: One disadvantage is that it requires extra work if you need to 'insert' new loops and data elements into the loop structures associated with an EDI transaction.  This is a bit outweighed by several advantages however: it is highly efficient to store EDI data when compared to the Flat BIN structure, with a single database row always representing a single occurrence of a loop in the EDI file, and it also is relatively simple to navigate and extract data.
Q: Does SERENEDI have a rules engine? What does it do?
A: Yes, along with its database capabilities, SERENEDI includes a rules engine to measure EDI compliance with the rules defined within the HIPAA Implementation Guides. The rules engine is user-extensible, meaning users can add their own custom rules to analyze incoming EDI transactions using the REP Code language.
Q: Does SERENEDI require internet access to run?
A: No, SERENEDI does not need internet access - as long as you are able to update a single license file once a year, SERENEDI should be able to run without interruption.
Q: What is a SCORE script in SERENEDI?
A: A SCORE script is a concatenation of SERENEDI and PowerShell Core. It's a sequence of commands that the background worker process executes to perform the task associated with the event.
Q: Why does SERENEDI have a separate Data Shuttle task?
A: By having a dedicated Data Shuttle task, it avoids the schema locks that would occur if multiple worker processes were trying to insert data and expand the schema at the same time.
Q: What is SERENEDI's SegPool register used for?
A: The SegPool register is used to represent the raw EDI document format. It provides a mechanism for loading and storing EDI documents to/from the file system.
Q: How does the HKey register differ from the SegPool register?
A: The HKey register is an internal representation of the EDI document that has been decoded from the SegPool register. It lays out the data in a hierarchical form that makes it easier to work with.
Q: What is the purpose of SERENEDI's Flat register?
A: The Flat register provides a two-dimensional view of the hierarchical data that is easy to work with for many common operations.
Q: How does the SERENEDI's Flat BIN database table interface work?
A: This is normally the easiest way to create or retrieve EDI transaction data, as all healthcare data for a transaction is projected into a single database table that can be querried or created. All the sample EDI transactions are created by a single stored procedure associated with each transaction to serve as a springboard for creating new transactions. This simplicity comes at the cost of highly denormalized data storage.
Q: How does SERENEDI use the Flat register interface to work with CSV files?
A: This stores data in exactly the same way as the flat database table, except that it's stored in CSV files on the file system. It's provided for use with legacy enterprise systems that can only accept or export CSV data. Also, CSV files can easily be opened with Microsoft Excel.
Q: What is the purpose of the built-in SERENEDI pipeline system?
A: The built-in pipeline system is designed to provide an accessible and easy way to use the core conversational features of Serenedi without having to directly write code for the platform.  These pipelines 'package' fixed parts of the engine functionality for ease-of-use.
Q: What does 'pipeline' refer to in the context of SERENEDI?
A: In SERENEDI, a pipeline refers to a business process that is associated with a SCORE script and one or more triggers in the automation system.
Q: What is the purpose of SERENEDI Pipeline 001: Readability?
A: This pipeline ensures files are formatted consistently in a human-readable form before further processing.  It sets all segment and element terminators to default values, and adds a carriage return and line feed after every segment.
Q: What is the purpose of SERENEDI Pipeline 002: CSVFromEDI?
A: Pipeline 002 converts incoming Electronic Data Interchange (EDI) files into Comma-Separated Values (CSV) format.  The resulting file will enclose all values within quotes and have a header row containing the column names. The first column name will be prefixed by the specification tag. The destination filename will be the same as the source filename, except with a.CSV extension.
Q: What is the purpose of SERENEDI Pipeline 003: CSVToEDI?
A: The purpose of this pipeline is to convert CGIF2 formatted CSV (comma-separated values) files into EDI (electronic data interchange) format.  If the conversion from CSV to EDI is successful, the resulting EDI file will inherit the same filename as the original CSV file, but with a .txt extension.
Q: What is the purpose of SERENEDI Pipeline 004: XMLFromEDI?
A: This pipeline converts incoming EDI files to CGIF2-formatted XML files.
Q: What is the purpose of SERENEDI Pipeline 005: XMLToEDI?
A: This pipeline converts CGIF2-formatted XML files into EDI files.
Q: What is the purpose of SERENEDI Pipeline 006: EDIToBIN?
A: This pipeline processes EDI files into the Flat BIN system in SERENEDI, converting all of the EDI elements into a two-dimensional database table.
Q: What is the purpose of SERENEDI Pipeline 007: EDIToHDB?
A: This pipeline processes EDI files into the HDB BIN system in SERENEDI, converting all of the EDI elements into a series of joined 'loop' tables.
Q: What is the purpose of SERENEDI Pipeline 008: BINToEDI?
A: This pipeline has two uses.  The first use generates EDI files from Flat and HDB BIN data that were previously imported into the SERENEDI BIN system.  The second use generates EDI files directly from database stored procedures using the Flat interface, bypassing the BIN system entirely.
Q: What is the purpose of SERENEDI Pipeline 009: Integrity?
A: This pipeline is used to assess the integrity of EDI files, and can provide an integrity report on errors within the EDI transaction.
Q: What is the purpose of SERENEDI Pipeline 010: Events?
A: This pipeline is an interface to create new events based off the contents of an XML file.  The results of the job will also be sent to an XML file once the event is completed.
Q: What data is stored within the serenediCore database?
A: The serenediCore distribution database contains all of the events, messages, and triggers, as well as the entire BIN system and related tables.  It also contains sample data and sample exports to provide a starting point for developers wishing to make new outbound transactions.
Q: How does SERENEDI convert a loaded HKey register into the Flat register?
A: "SERENEDI goes through these steps when transforming an HKey register into the Flat register:1.First, every possible mapping is extracted from the loaded hierarchical structure and a series of CGIF2 maps is created.
2.The deepest repeating loop is marked; data mapped within this loop will always trigger a new row.  The NEWROW column is defaulted to 1.
3.The HKey is hierarchy is navigated and loops are encoded into the two dimensional structure as they are encountered.  When more than one cutout is encountered, the new row is dedicated to storing the data from the cutout, and the NEWROW column is set to 0."
Q: What is SERENEDI's Hierarchical Database Interface?
A: The Hierarchical Database (HDB) interface provides an alternative method to storing SQL query-accessible transaction data compared to the Flat interface. Instead of a single database table, one database table per loop is utilized in the transaction, joined together in parent-child relationships that exactly mirror the structure of the EDI transaction.
Q: How are the SERENEDI HDB BIN system tables named?
A: By default, the names of the HDB tables begin with HDB_5010, an underscore, the short specification name without any Addenda suffix, an underscore, and the loop short name. A collection of HDB tables for a specific transaction is called an HDB tableset.
Q: What columns are within a SERENEDI HDB table?
A: The layout of every HDB table begins with four columns: PK_ID (int): Primary key, auto-generated identity column; BIN_ID (int): Foreign key reference to the BIN_LOG table; BIN_IX (int): BIN Index, a numerically increasing index starting at 1 for every new BIN_ID; PAR_BIN_IX (int): Parent BIN_IX, relates this loop's maps and data to the parent BIN_IX identifier.  This column is not present in the ISA loop table.
Q: What additional field is there for 837 HDB tables?
A: The PAR_2000C_IX (int) occurs only in 837 I / P L2300 Claim loops, and links this claim to iterations within the L2000C Patient loop table.
Q: Are the SERENEDI HDB maps the same as in the SERENEDI FLAT maps?
A: The CGIF2 mappings are very similar between both the Flat and HDB interfaces, with one key difference being that all iteration counters for Single Iteration and Value Iteration maps are locked to the value of 01.  In this case, the hierarchical database structure itself encodes this information.
Q: Are there potential problems with manually inserting data into SERENEDI HDB BIN tables?
A: Child loops need to occur in an order that is synchronized with parent loops; in other words, SERENEDI is expecting both the BIN_IX and the PAR_BIN_IX key columns to occur in an incrementing and ascending order to be able to register the database rows as valid child loops. This means that you cannot arbitrarily insert new children loops by adding new rows to the bottom of the data associated with that BIN_ID; all child loops pertaining to the same PAR_BIN_IX parent loop reference must be grouped together in ascending order in relation to the BIN_IX key.
Q: In SERENEDI, Do loops with the same short name mean the same thing in different specifications?
A: No, the full loop name will likely be very different and the loop will have different business functions.
Q: In the HIPAA Implementation Guides, a claim in the 837 specifications is described as 'floating' under either the 2000B or the 2000C loop.  How is this implemented in SERENEDI?
A: SERENEDI implements this behavior by treating a possible 2000C loop as a secondary and optional parent key to the 2300 claim loops.  How this works is somewhat context dependent; in the XML interface, the 2000C loop will immediately precede the 2300 claim loop.  In the Flat interface, 2000C information will be populated for associated claims.  In the HDB interface, the 2300 loop has a PAR_2000C_IX optional foreign key that references populated 2000C loops.
Q: What is a SERENEDI SQL Trigger?
A: In SERENEDI, this is a special type of a trigger that generates events when a specific SQL query returns the value of '1'.  In this way, complex SQL logic can be used to generate events on an as-needed basis.
Q: What is a SERENEDI Upload Trigger?
A: SERENEDI Upload Triggers provide a way to generate events based off of incoming files.  Upload triggers have an initial and source folder; when a file is transferred to the initial folder, the SERENEDI service tries to move it to the source folder, and if successful, it generates an event on that file that is now in the source folder.  If the file cannot be moved, it is assumed to be locked and no trigger is generated.  This process ensures the file is completely finished writing before processing.
Q: What is a SERENEDI Archive Trigger?
A: SERENEDI Archive Triggers provide a way to generate events based off of incoming files.  When a new file appears that has not been processed by the event system previously, a new event is generated.  Because this method requires a comparison with all prior files every time the folder is checked, it is slower than the Upload trigger method and therefore less suitable for processes that require a quick turnaround.
Q: How does SERENEDI process new events?
A: When a new event is added to the BIZ_EVENT table on the serenediCore distribution database, each event gets a new unique BIZ_EVENT_ID.  The background SerenediService examines the current workload for each trigger, and allocates worker processes to process events according to an internal load-balancing algorithm.  Each worker process then executes the SCORE script associated with that trigger with the parameters that are part of the event, until the event is completed processing.  Then, any messages that are accumulated are sent to the BIZ_MSG table along with the BIZ_EVENT_ID as a foreign key.
Q: What is the fire logic field associated with SERENEDI triggers?
A: The fire logic field is a way to manipulate how SERENEDI generates events.  Fire logic can be used in conjunction with the two file-based triggers to filter when events are generating based on the filename and/or extension.  Fire logic can also be used to add a date/timestamp to a filename for Upload triggers to ensure unique filenames, which allows files with the same filename to be processed repeatedly.  Finally, the SQL field specifies the syntax of the SQL SELECT statement that SERENEDI executes to check if a SQL trigger has fired.
Q: What are the file filters used in the fire logic field for SERENEDI triggers?
A: File filter enables two different sets of functionality for the SERENEDI Archive and Upload triggers.  First, it enables ? and * filename wildcards to enable filtering based off of extension or filename, limiting event firing only when specific file naming criterion are met.  For example, when the Fire Logic field is populated with the string 'FILTER:ELIG????????.834', it means events will only be generated for files that start with 'ELIG' and end with '.834' and have an eight character string between them.  If the Fire Logic field is populated with 'FILTER:Z1*.TXT', it means it will only process files that start with Z1 and ends with .TXT.  Filters can also be combined with a '|' character.  For example, 'FILTER:Z1*.TXT|FILTER:Z2*.TXT' means that events will only be fired if both criterion are satisfied - although only the first file will be triggered, it will only be triggered if there is an accompanying Z2 file with the same wildcard characters as the corresponding Z1* file.
Q: What is the Timestamp functionality of the Fire Logic?
A: This allows the suffixing of a timestamp to a filename for SERENEDI Upload Trigger filenames, and is a way to enable processing of files that have the same filename.  Normally, files will sit in the 'Initial' folder of an Upload trigger if there is already a file with the same name in the 'Source' folder, and not be processed.  When the trigger has a fire logic string with the string 'TIMESTAMP:yyyyMMddHHmm', then a suffix with a .NET-style date time formatting string will be added to the filename and it will be able to be processed.  In this case, the yyyyMMddHHmm string will add a suffix of 202307171445 for July 17th, 2:45 PM to any files placed in the Upload folder.
Q: What are some specific things that differentiate a SERENEDI PowerShell Core - or SCORE - script from a normal PowerShell Core script?
A: First, there several predefined variables that are associated with a specific event that get loaded prior to the script's execution.  Second, there is a special runtime session environment that exposes the SERENEDI engine's functionality to the script.  Thirdly, about 60+ PowerShell Core cmdlets give direct access to the methods and functionality of the SERENEDI engine.
Q: What are the preloaded variables associated with a SERENEDI runtime session within a SCORE script?
A: The first variable is $basePath, which is the base SERENEDI installation folder.  Then there is $eventData1, $eventData2, $eventData3 and $eventData4 which are four string variables passed from the EVENT_ARG1, EVENT_ARG2, EVENT_ARG3 and EVENT_ARG4 columns from the event.  $eventCrit contains the EVENT_CRIT column.  $folderSrc contains the value of the source folder for this trigger.  $mainScript is the path to the SCORE script being executed.
